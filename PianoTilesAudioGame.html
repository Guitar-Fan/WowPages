<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Custom Audio Tiles Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <style>
    body {
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(135deg, #f6e5bb 0%, #c29b5e 100%);
      font-family: 'Georgia', serif;
      color: #5b3a14;
      overflow-x: hidden;
    }
    header {
      text-align: center;
      font-size: 2rem;
      font-weight: bold;
      margin-top: 1rem;
      margin-bottom: 0.6rem;
      letter-spacing: 2px;
      text-shadow: 0 2px 8px #fff7, 0 1px 0 #c29b5e;
    }
    #desc {
      text-align: center;
      margin: 0.8rem auto 0.4rem auto;
      font-size: 1.07rem;
      max-width: 540px;
      color: #7a5724;
      text-shadow: 0 1px 0 #f9e8c7;
    }
    #container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100vw;
      max-width: 100vw;
      box-sizing: border-box;
    }
    #game-canvas {
      width: 98vw;
      max-width: 400px;
      height: 62vw;
      max-height: 620px;
      background: linear-gradient(120deg,#f7e5c2 0,#e3b76b 100%);
      border-radius: 20px;
      border: 4px solid #b9935e;
      box-shadow: 0 8px 36px #825f3f40, 0 2px 12px #5b3a1430;
      display: block;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }
    #spectrum-canvas {
      width: 98vw !important;
      max-width: 400px;
      height: 40vw !important;
      max-height: 160px;
      display: block;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1.6rem;
      margin-bottom: 1rem;
      margin-top: 0.6rem;
    }
    .lane-label-input {
      width: 2.6rem;
      font-size: 1.2rem;
      text-align: center;
      border-radius: 6px;
      border: 1px solid #bfa764;
      padding: 0.3rem 0.1rem;
      background: #fffbe8;
      color: #8d6b36;
      box-shadow: 0 2px 6px #e7ccb7 inset;
    }
    .lane-label-input:focus {
      outline: 2px solid #cba76d;
    }
    #midi-load-controls {
      display: flex;
      align-items: center;
      gap: 1.5rem;
      justify-content: center;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }
    #playback-controls {
      display: flex;
      align-items: center;
      gap: 1.2rem;
      justify-content: center;
      margin-bottom: 1rem;
      font-size: 1.03rem;
      flex-wrap: wrap;
    }
    #play-btn, #stop-btn {
      font-size: 1rem;
      background: #ffe065;
      color: #8b6128;
      border: 1.5px solid #bfa764;
      border-radius: 6px;
      padding: 0.4rem 1.1rem;
      font-family: 'Georgia', serif;
      font-weight: bold;
      cursor: pointer;
      margin-left: 0.6rem;
      margin-right: 0.6rem;
      margin-top: 0.2rem;
    }
    #play-btn:active, #stop-btn:active {
      background: #e3b76b;
    }
    input[type="range"] {
      accent-color: #bfa764;
    }
    #midi-upload {
      font-size: 1rem;
      background: #fffbe8;
      border-radius: 6px;
      border: 1px solid #bfa764;
      color: #8b6128;
      padding: 0.3rem 0.6rem;
      cursor: pointer;
    }
    #loading-anim {
      display: none;
      position: fixed;
      left:0; right:0; top:0; bottom:0;
      background: rgba(255,255,220,0.7);
      z-index: 99;
      justify-content: center;
      align-items: center;
    }
    .lds-ring {
      display: inline-block;
      position: relative;
      width: 70px;
      height: 70px;
    }
    .lds-ring div {
      box-sizing: border-box;
      display: block;
      position: absolute;
      width: 56px;
      height: 56px;
      margin: 8px;
      border: 7px solid #bfa764;
      border-radius: 50%;
      animation: lds-ring 1.15s cubic-bezier(0.4,0,0.2,1) infinite;
      border-color: #bfa764 transparent transparent transparent;
    }
    .lds-ring div:nth-child(1) { animation-delay: -0.32s; }
    .lds-ring div:nth-child(2) { animation-delay: -0.16s; }
    @keyframes lds-ring {
      0% { transform: rotate(0deg);}
      100% { transform: rotate(360deg);}
    }
    @media (max-width: 600px) {
      #game-canvas {
        width: 96vw !important;
        height: 66vw !important;
        max-width: 96vw;
        max-height: 66vw;
      }
      #spectrum-canvas {
        width: 96vw !important;
        height: 32vw !important;
        max-width: 96vw;
        max-height: 32vw;
      }
      #lane-controls, #audio-progress-container {
        width: 96vw !important;
        max-width: 96vw;
      }
      #controls {
        flex-direction: column;
        gap: 0.6rem;
      }
    }
  </style>
</head>
<body>
  <header>
    Classical Audio Tiles Demo
  </header>
  <div id="desc">
    Upload an audio file (mp3, wav, flac, etc.), set your keys, and play!<br>
    Tiles are generated when a frequency region crosses a threshold dB level.<br>
    <b>Playback rate: </b>change to make tiles fall faster/slower.
  </div>
  <div id="midi-load-controls">
    <label>
      <input type="file" id="audio-upload" accept="audio/*">
      <span>Upload Audio</span>
    </label>
  </div>
  <div id="playback-controls">
    <span>Playback Rate: <span id="rate-value">1.0</span>x</span>
    <input type="range" id="rate-range" min="0.5" max="2.0" step="0.05" value="1.0">
    <button id="play-btn">Play</button>
    <button id="stop-btn">Stop</button>
  </div>
  <div id="controls">
    <div>
      <label>Lane 1: <input class="lane-label-input" id="label-0" value="D" maxlength="1"></label>
    </div>
    <div>
      <label>Lane 2: <input class="lane-label-input" id="label-1" value="F" maxlength="1"></label>
    </div>
    <div>
      <label>Lane 3: <input class="lane-label-input" id="label-2" value="J" maxlength="1"></label>
    </div>
    <div>
      <label>Lane 4: <input class="lane-label-input" id="label-3" value="K" maxlength="1"></label>
    </div>
  </div>
  <div id="container">
    <canvas id="game-canvas" width="400" height="620"></canvas>
    <div style="display:flex;flex-direction:column;align-items:center;width:100%;">
      <canvas id="spectrum-canvas" width="400" height="160"></canvas>
      <div id="lane-controls"></div>
    </div>
  </div>
  <div id="audio-progress-container">
    <input type="range" id="audio-progress" min="0" max="100" value="0" step="0.01" style="width:100%;accent-color:#bfa764;">
    <div style="display:flex;justify-content:space-between;font-size:0.95rem;color:#8b6128;">
      <span id="audio-current">0:00</span>
      <span id="audio-duration">0:00</span>
    </div>
  </div>

  <!-- Loading animation overlay with progress feedback -->
  <div id="loading-anim">
    <div class="lds-ring"><div></div><div></div><div></div><div></div></div>
    <div style="display:flex;flex-direction:column;align-items:left;margin-left:1.5rem;">
      <span style="font-size:1.4rem;color:#8b6128;" id="loading-msg">Processing audio...</span>
      <span style="font-size:1.07rem;color:#7a5724;margin-top:0.2rem;" id="loading-progress"></span>
    </div>
  </div>

  <script>
    // --- CONFIG ---
    const LANES = 4;
    const LANE_COLORS = ["#ad8d54", "#e3b76b", "#b88949", "#cba76d"];
    const TILE_WIDTH_RATIO = 0.75;
    const TILE_HEIGHT = 60;
    const BASE_TILE_SPEED = 3.2; // px/frame, at 1.0x playback
    const TILE_SPAWN_GAP = 12; // minimal vertical gap between tiles in a lane (px)
    const HIT_LINE_Y = 510;
    const CIRCLE_RADIUS = 36;
    const CIRCLE_Y = 560;
    const FPS = 60;

    // --- STATE ---
    let laneLabels = ["D", "F", "J", "K"];
    let canvas = document.getElementById('game-canvas');
    let ctx = canvas.getContext('2d');
    let W = canvas.width, H = canvas.height;
    let LANE_WIDTH = W / LANES;
    let playbackRate = 1.0;
    let tiles = Array.from({length: LANES}, () => []);
    let startTime = null;
    let isPlaying = false;

    // --- AUDIO STATE ---
    let audioCtx = null;
    let audioSource = null;
    let analyser = null;
    let audioBuffer = null;
    let audioElement = null;
    const SPECTRUM_W = 400;
    const SPECTRUM_H = 160;
    const SPECTRUM_FFT_SIZE = 2048;
    const SPECTRUM_MIN_DB = 40;  // Lower dB for display
    const SPECTRUM_MAX_DB = 140; // Upper dB for display

    // --- FREQUENCY REGION CONTROLS ---
    let freqRegions = [
      {min: 60, max: 250},   // Lane 1: Bass
      {min: 251, max: 1000}, // Lane 2: Low-mid
      {min: 1001, max: 3000},// Lane 3: High-mid
      {min: 3001, max: 8000} // Lane 4: Treble
    ];
    let regionThresholds = [120, 110, 100, 95]; // dB thresholds for each lane

    // --- LANE LABEL INPUTS ---
    for (let i = 0; i < LANES; ++i) {
      const inp = document.getElementById('label-' + i);
      inp.value = laneLabels[i];
      inp.addEventListener('input', e => {
        let val = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
        if (val.length > 1) val = val[0];
        laneLabels[i] = val || "?";
        e.target.value = laneLabels[i];
        drawCircles();
      });
    }

    // --- PLAYBACK RATE ---
    const rateRange = document.getElementById('rate-range');
    const rateValue = document.getElementById('rate-value');
    rateRange.addEventListener('input', e => {
      playbackRate = parseFloat(e.target.value);
      rateValue.textContent = playbackRate.toFixed(2).replace(/\.00$/, "");
      if (audioElement) audioElement.playbackRate = playbackRate;
    });

    // --- AUDIO PROGRESS BAR ---
    const audioProgress = document.getElementById('audio-progress');
    const audioCurrent = document.getElementById('audio-current');
    const audioDuration = document.getElementById('audio-duration');
    let audioDurationSec = 0;

    function formatTime(sec) {
      sec = Math.floor(sec);
      let m = Math.floor(sec/60);
      let s = sec%60;
      return `${m}:${s.toString().padStart(2,'0')}`;
    }

    function updateAudioProgress() {
      if (audioElement && audioElement.duration) {
        audioDurationSec = audioElement.duration;
        audioProgress.max = audioDurationSec;
        audioProgress.value = audioElement.currentTime;
        audioCurrent.textContent = formatTime(audioElement.currentTime);
        audioDuration.textContent = formatTime(audioDurationSec);
      } else {
        audioProgress.value = 0;
        audioCurrent.textContent = "0:00";
        audioDuration.textContent = "0:00";
      }
    }

    // Seek when user interacts with progress bar
    audioProgress.addEventListener('input', function(e) {
      if (audioElement && audioElement.duration) {
        const wasPlaying = isPlaying;
        if (wasPlaying) audioElement.pause();
        audioElement.currentTime = parseFloat(e.target.value);
        updateAudioProgress();
        if (wasPlaying) audioElement.play();
      }
    });

    // --- AUDIO UPLOAD & ANALYSIS ---
    document.getElementById('audio-upload').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      if (audioElement) {
        audioElement.pause();
        audioElement = null;
      }
      const url = URL.createObjectURL(file);
      audioElement = new Audio(url);
      audioElement.crossOrigin = "anonymous";
      audioElement.oncanplay = () => {
        setupAudioAnalysis();
        updateAudioProgress();
        drawSpectrum(new Uint8Array(SPECTRUM_FFT_SIZE/2), audioCtx ? audioCtx.sampleRate : 44100);
      };
      audioElement.ontimeupdate = updateAudioProgress;
      audioElement.onended = () => { isPlaying = false; updateAudioProgress(); };
    });

    // UI controls for frequency regions and thresholds
    function renderLaneControls() {
      const laneControls = document.getElementById('lane-controls');
      laneControls.innerHTML = '';
      for (let i = 0; i < LANES; ++i) {
        const laneDiv = document.createElement('div');
        laneDiv.style.display = 'flex';
        laneDiv.style.alignItems = 'center';
        laneDiv.style.marginBottom = '4px';
        laneDiv.innerHTML = `
          <span style="width:60px;color:${LANE_COLORS[i]};font-weight:bold;">Lane ${i+1}</span>
          <label style="margin-left:8px;">Min Hz: <input type="number" min="20" max="20000" value="${freqRegions[i].min}" id="freq-min-${i}" style="width:60px;"></label>
          <label style="margin-left:8px;">Max Hz: <input type="number" min="20" max="20000" value="${freqRegions[i].max}" id="freq-max-${i}" style="width:60px;"></label>
          <label style="margin-left:8px;">Threshold: <input type="number" min="${SPECTRUM_MIN_DB}" max="${SPECTRUM_MAX_DB}" value="${regionThresholds[i]}" id="thresh-${i}" style="width:50px;"></label>
        `;
        laneControls.appendChild(laneDiv);
        // Add listeners
        laneDiv.querySelector(`#freq-min-${i}`).addEventListener('input', e => {
          freqRegions[i].min = Math.max(20, Math.min(freqRegions[i].max-1, parseInt(e.target.value)||20));
        });
        laneDiv.querySelector(`#freq-max-${i}`).addEventListener('input', e => {
          freqRegions[i].max = Math.min(20000, Math.max(freqRegions[i].min+1, parseInt(e.target.value)||20000));
        });
        laneDiv.querySelector(`#thresh-${i}`).addEventListener('input', e => {
          regionThresholds[i] = Math.max(SPECTRUM_MIN_DB, Math.min(SPECTRUM_MAX_DB, parseInt(e.target.value)||SPECTRUM_MIN_DB));
        });
      }
    }
    renderLaneControls();

    function setupAudioAnalysis() {
      if (audioCtx) audioCtx.close();
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      audioSource = audioCtx.createMediaElementSource(audioElement);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = SPECTRUM_FFT_SIZE;
      audioSource.connect(analyser);
      analyser.connect(audioCtx.destination);
      isPlaying = false;
      resetGame();
      drawAll();
      drawSpectrum(new Uint8Array(SPECTRUM_FFT_SIZE/2), audioCtx.sampleRate);
    }

    // --- GAME BUTTONS ---
    document.getElementById('play-btn').onclick = () => {
      if (audioElement) {
        // User interaction is required to start/resume AudioContext
        if (audioCtx && audioCtx.state === 'suspended') {
          audioCtx.resume();
        }
        audioElement.playbackRate = playbackRate;
        audioElement.play();
        isPlaying = true;
        startTime = performance.now();
      }
    };
    document.getElementById('stop-btn').onclick = () => {
      if (audioElement) audioElement.pause();
      isPlaying = false;
      // Don't reset the game, just pause it.
      // resetGame(); 
      drawAll();
      updateAudioProgress();
    };

    function resetGame() {
      tiles = Array.from({length: LANES}, () => []);
      earlyPressAnim = Array(LANES).fill(0);
    }

    // --- TILE GENERATION BASED ON FREQUENCY REGION ---
    let lastTileTime = Array(LANES).fill(-100);
    let minTileGap = 0.22; // seconds between tiles in same lane

    function detectAndGenerateTiles(audioTime, freqData, freqBins, sampleRate) {
      for (let lane = 0; lane < LANES; ++lane) {
        let region = freqRegions[lane];
        // Find bins corresponding to region
        let minBin = Math.floor(region.min / (sampleRate/2) * freqBins.length);
        let maxBin = Math.ceil(region.max / (sampleRate/2) * freqBins.length);
        minBin = Math.max(0, minBin);
        maxBin = Math.min(freqBins.length-1, maxBin);
        // Get max dB in region
        let maxDb = -Infinity;
        for (let i = minBin; i <= maxBin; ++i) {
          // Convert byte value (0-255) to dB value
          let db = (freqData[i] / 255) * (analyser.maxDecibels - analyser.minDecibels) + analyser.minDecibels;
          maxDb = Math.max(maxDb, db);
        }
        // If above threshold and enough time since last tile, spawn tile
        if (maxDb > regionThresholds[lane] && audioTime - lastTileTime[lane] > minTileGap) {
          let last = tiles[lane].length > 0 ? tiles[lane][tiles[lane].length-1] : null;
          let canSpawn = !last || last.y <= -TILE_HEIGHT - TILE_SPAWN_GAP;
          if (canSpawn) {
            tiles[lane].push(makeTile(lane, LANE_COLORS[lane]));
            lastTileTime[lane] = audioTime;
          }
        }
      }
    }

    // --- SPECTRUM ANALYZER CONFIG ---
    const spectrumCanvas = document.getElementById('spectrum-canvas');
    const spectrumCtx = spectrumCanvas.getContext('2d');

    // --- SPECTRUM DRAWING ---
    function drawSpectrum(freqData, sampleRate) {
      spectrumCtx.clearRect(0, 0, SPECTRUM_W, SPECTRUM_H);

      // Draw dB grid lines and labels
      spectrumCtx.save();
      spectrumCtx.font = "11px Georgia";
      spectrumCtx.fillStyle = "#8b6128";
      spectrumCtx.strokeStyle = "#bfa764";
      for (let db = SPECTRUM_MIN_DB; db <= SPECTRUM_MAX_DB; db += 20) {
        let y = SPECTRUM_H - ((db-SPECTRUM_MIN_DB)/(SPECTRUM_MAX_DB-SPECTRUM_MIN_DB))*SPECTRUM_H;
        spectrumCtx.beginPath();
        spectrumCtx.moveTo(0, y);
        spectrumCtx.lineTo(SPECTRUM_W, y);
        spectrumCtx.stroke();
        spectrumCtx.fillText(db + " dB", 2, y-2);
      }
      spectrumCtx.restore();

      // Draw frequency grid lines and labels
      spectrumCtx.save();
      spectrumCtx.font = "11px Georgia";
      spectrumCtx.fillStyle = "#8b6128";
      spectrumCtx.strokeStyle = "#bfa764";
      let freqTicks = [50,100,200,500,1000,2000,5000,10000,16000];
      for (let f of freqTicks) {
        let x = freqToX(f, sampleRate);
        spectrumCtx.beginPath();
        spectrumCtx.moveTo(x, 0);
        spectrumCtx.lineTo(x, SPECTRUM_H);
        spectrumCtx.stroke();
        spectrumCtx.fillText(f + "Hz", x+2, SPECTRUM_H-4);
      }
      spectrumCtx.restore();

      // Draw spectrum bars
      for (let i = 0; i < freqData.length; ++i) {
        let freq = i * sampleRate / (2 * freqData.length);
        let x = freqToX(freq, sampleRate);
        let db = (freqData[i] / 255) * (analyser.maxDecibels - analyser.minDecibels) + analyser.minDecibels;
        let y = SPECTRUM_H - ((db-SPECTRUM_MIN_DB)/(SPECTRUM_MAX_DB-SPECTRUM_MIN_DB))*SPECTRUM_H;
        let color = `rgb(${220+Math.floor(35*i/freqData.length)},${180+Math.floor(75*i/freqData.length)},${40+Math.floor(180*i/freqData.length)})`;
        spectrumCtx.fillStyle = color;
        spectrumCtx.fillRect(x, y, 2, SPECTRUM_H-y);
      }

      // Draw lane regions and threshold lines
      for (let lane = 0; lane < LANES; ++lane) {
        let minX = freqToX(freqRegions[lane].min, sampleRate);
        let maxX = freqToX(freqRegions[lane].max, sampleRate);
        // Vertical region lines
        spectrumCtx.save();
        spectrumCtx.strokeStyle = LANE_COLORS[lane];
        spectrumCtx.lineWidth = 2;
        spectrumCtx.beginPath();
        spectrumCtx.moveTo(minX, 0);
        spectrumCtx.lineTo(minX, SPECTRUM_H);
        spectrumCtx.moveTo(maxX, 0);
        spectrumCtx.lineTo(maxX, SPECTRUM_H);
        spectrumCtx.stroke();
        spectrumCtx.restore();
        // Fill region
        spectrumCtx.save();
        spectrumCtx.globalAlpha = 0.08;
        spectrumCtx.fillStyle = LANE_COLORS[lane];
        spectrumCtx.fillRect(minX, 0, maxX-minX, SPECTRUM_H);
        spectrumCtx.restore();
        // Threshold line
        let threshY = SPECTRUM_H - ((regionThresholds[lane]-SPECTRUM_MIN_DB)/(SPECTRUM_MAX_DB-SPECTRUM_MIN_DB))*SPECTRUM_H;
        spectrumCtx.save();
        spectrumCtx.strokeStyle = LANE_COLORS[lane];
        spectrumCtx.setLineDash([4,3]);
        spectrumCtx.beginPath();
        spectrumCtx.moveTo(minX, threshY);
        spectrumCtx.lineTo(maxX, threshY);
        spectrumCtx.stroke();
        spectrumCtx.setLineDash([]);
        spectrumCtx.restore();
      }
    }

    function freqToX(freq, sampleRate) {
      // Log scale mapping for better visualization
      let minF = 20, maxF = sampleRate/2;
      let logMin = Math.log10(minF), logMax = Math.log10(maxF);
      let logFreq = Math.log10(Math.max(minF, freq));
      let norm = (logFreq-logMin)/(logMax-logMin);
      return Math.floor(norm * SPECTRUM_W);
    }

    // --- MAIN ANIMATION LOOP (10ms resolution for spectrum) ---
    let lastSpectrumDraw = 0;
    function animate(now) {
      drawAll();
      let drawSpectrumNow = (!lastSpectrumDraw || now-lastSpectrumDraw >= 10);

      if (audioElement && analyser) {
        if (isPlaying) {
            let freqData = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(freqData);
            if (drawSpectrumNow) {
              drawSpectrum(freqData, audioCtx.sampleRate);
              lastSpectrumDraw = now;
            }
            let audioTime = audioElement.currentTime;
            detectAndGenerateTiles(audioTime, freqData, freqData, audioCtx.sampleRate);
        } else if (drawSpectrumNow) {
            // Draw empty spectrum if paused
            let dummy = new Uint8Array(analyser.frequencyBinCount);
            drawSpectrum(dummy, audioCtx.sampleRate);
            lastSpectrumDraw = now;
        }
      } else if (drawSpectrumNow) {
        // Fallback before audio is loaded
        let dummy = new Uint8Array(SPECTRUM_FFT_SIZE/2);
        drawSpectrum(dummy, 44100);
        lastSpectrumDraw = now;
      }

      // Tile animation logic (runs regardless of play state)
      if (audioElement) { // Game is loaded
        for (let lane = 0; lane < LANES; ++lane) {
          for (let tile of tiles[lane]) {
            if (tile.state === "falling") {
              if (isPlaying) tile.y += BASE_TILE_SPEED * playbackRate;
              if (tile.y > HIT_LINE_Y + 32 && tile.state === "falling") {
                tile.state = "missed";
                tile.anim = 0;
              }
            } else if (tile.state === "hit" || tile.state === "missed" || tile.state === "early") {
              tile.anim++;
            }
          }
          tiles[lane] = tiles[lane].filter(tile =>
            (tile.state === "falling") ||
            (tile.state === "hit" && tile.anim < 12) ||
            (tile.state === "missed" && tile.anim < 9) ||
            (tile.state === "early" && tile.anim < 9)
          );
        }
        if (audioElement.ended) {
          isPlaying = false;
        }
      } else { // Fallback random tile mode
        spawnTiles();
        for (let lane = 0; lane < LANES; ++lane) {
          for (let tile of tiles[lane]) {
            if (tile.state === "falling") {
              tile.y += BASE_TILE_SPEED;
              if (tile.y > HIT_LINE_Y + 32 && tile.state === "falling") {
                tile.state = "missed";
                tile.anim = 0;
              }
            } else if (tile.state === "hit" || tile.state === "missed") {
              tile.anim++;
            }
          }
          tiles[lane] = tiles[lane].filter(tile =>
            (tile.state === "falling") ||
            (tile.state === "hit" && tile.anim < 12) ||
            (tile.state === "missed" && tile.anim < 9)
          );
        }
      }

      updateAudioProgress();
      requestAnimationFrame(animate);
    }
    // Start with one tile per lane for fallback
    if (!audioElement) {
      for (let i = 0; i < LANES; ++i) {
        tiles[i].push(makeTile(i, LANE_COLORS[i]));
      }
    }
    animate();
  </script>
</body>
</html>