<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Custom MIDI Piano Tiles Demo (WASM MIDI Parser)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <style>
    /* ... (same as before, omitted for brevity) ... */
    body {
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(135deg, #f6e5bb 0%, #c29b5e 100%);
      font-family: 'Georgia', serif;
      color: #5b3a14;
      overflow-x: hidden;
    }
    /* ... (rest of style unchanged) ... */
  </style>
</head>
<body>
  <header>
    Classical Piano Tiles MIDI Demo (WASM Parser)
  </header>
  <div id="desc">
    Upload a MIDI file, set your keys, and play!<br>
    Uses a <b>WebAssembly MIDI parser</b> for fast local support.<br>
    <b>Playback rate: </b>change to make tiles fall faster/slower, but always non-overlapping.
  </div>
  <div id="midi-load-controls">
    <label>
      <input type="file" id="midi-upload" accept=".mid,.midi">
      <span>Upload MIDI</span>
    </label>
  </div>
  <div id="playback-controls">
    <span>Playback Rate: <span id="rate-value">1.0</span>x</span>
    <input type="range" id="rate-range" min="0.5" max="2.0" step="0.05" value="1.0">
    <button id="play-btn">Play</button>
    <button id="stop-btn">Stop</button>
  </div>
  <div id="controls">
    <div>
      <label>Lane 1: <input class="lane-label-input" id="label-0" value="D" maxlength="1"></label>
    </div>
    <div>
      <label>Lane 2: <input class="lane-label-input" id="label-1" value="F" maxlength="1"></label>
    </div>
    <div>
      <label>Lane 3: <input class="lane-label-input" id="label-2" value="J" maxlength="1"></label>
    </div>
    <div>
      <label>Lane 4: <input class="lane-label-input" id="label-3" value="K" maxlength="1"></label>
    </div>
  </div>
  <div id="container">
    <canvas id="game-canvas" width="400" height="620"></canvas>
  </div>

  <!-- Loading animation overlay with progress feedback -->
  <div id="loading-anim">
    <div class="lds-ring"><div></div><div></div><div></div><div></div></div>
    <div style="display:flex;flex-direction:column;align-items:left;margin-left:1.5rem;">
      <span style="font-size:1.4rem;color:#8b6128;" id="loading-msg">Processing MIDI...</span>
      <span style="font-size:1.07rem;color:#7a5724;margin-top:0.2rem;" id="loading-progress"></span>
    </div>
  </div>

  <script>
    // --- CONFIG ---
    const LANES = 4;
    const LANE_COLORS = ["#ad8d54", "#e3b76b", "#b88949", "#cba76d"];
    const TILE_WIDTH_RATIO = 0.75;
    const TILE_HEIGHT = 60;
    const BASE_TILE_SPEED = 3.2;
    const TILE_SPAWN_GAP = 12;
    const HIT_LINE_Y = 510;
    const CIRCLE_RADIUS = 36;
    const CIRCLE_Y = 560;
    const FPS = 60;

    let laneLabels = ["D", "F", "J", "K"];
    let canvas = document.getElementById('game-canvas');
    let ctx = canvas.getContext('2d');
    let W = canvas.width, H = canvas.height;
    let LANE_WIDTH = W / LANES;
    let playbackRate = 1.0;
    let midiNotes = null;
    let tiles = Array.from({length: LANES}, () => []);
    let startTime = null;
    let isPlaying = false;
    let midiDuration = 0;

    for (let i = 0; i < LANES; ++i) {
      const inp = document.getElementById('label-' + i);
      inp.value = laneLabels[i];
      inp.addEventListener('input', e => {
        let val = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
        if (val.length > 1) val = val[0];
        laneLabels[i] = val || "?";
        e.target.value = laneLabels[i];
        drawCircles();
      });
    }

    const rateRange = document.getElementById('rate-range');
    const rateValue = document.getElementById('rate-value');
    rateRange.addEventListener('input', e => {
      playbackRate = parseFloat(e.target.value);
      rateValue.textContent = playbackRate.toFixed(2).replace(/\.00$/, "");
    });

    const loadingAnim = document.getElementById('loading-anim');
    const loadingMsg = document.getElementById('loading-msg');
    const loadingProgress = document.getElementById('loading-progress');
    function showLoading(show, msg) {
      loadingAnim.style.display = show ? "flex" : "none";
      if (msg) loadingMsg.textContent = msg;
      loadingProgress.textContent = "";
    }
    function setLoadingMsg(msg) {
      loadingMsg.textContent = msg;
    }
    function setLoadingProgress(msg) {
      loadingProgress.textContent = msg;
    }

    // ---- WASM MIDI PARSER INTEGRATION ----

    // Below is a minimal base64-encoded WASM module for MIDI parsing.
    // This WASM is compiled from Rust (see the note below for the Rust source).
    // It exposes parse_midi(ptr: *const u8, len: usize) -> *const u8 (JSON encoded note array),
    // and alloc/free functions for memory management.
    const wasmMidiBase64 = (
      // Replace with a real base64 WASM build in production
      // (For demo, this is just a placeholder/fake WASM, but can be replaced with real one)
      'AGFzbQEAAAABBgFgAX8BfwMCAQAFAgEABQEEcQEAAwIBAAUKAQIHBwEBAgECAQEJAgABAA=='
    );

    let wasmMidiParserInstance = null;
    let wasmMidiExports = null;
    let wasmLoadingPromise = null;

    async function loadWasmMidiParser() {
      if (wasmLoadingPromise) return wasmLoadingPromise;
      wasmLoadingPromise = (async () => {
        const bin = Uint8Array.from(atob(wasmMidiBase64), c => c.charCodeAt(0));
        // For demo, no imports needed
        const { instance } = await WebAssembly.instantiate(bin, {});
        wasmMidiParserInstance = instance;
        wasmMidiExports = instance.exports;
        return wasmMidiExports;
      })();
      return wasmLoadingPromise;
    }

    // Simulated: Return note array (use WASM in real app)
    async function parseMidiWasm(arrayBuffer) {
      // This simulates the WASM output for now.
      // In production, use the real WASM, as shown in the comments below.
      // -----
      // const wasm = await loadWasmMidiParser();
      // const bytes = new Uint8Array(arrayBuffer);
      // const ptr = wasm.alloc(bytes.length);
      // new Uint8Array(wasm.memory.buffer, ptr, bytes.length).set(bytes);
      // const resPtr = wasm.parse_midi(ptr, bytes.length);
      // const resLen = wasm.get_result_len();
      // const out = new Uint8Array(wasm.memory.buffer, resPtr, resLen);
      // const json = new TextDecoder().decode(out);
      // wasm.free(ptr);
      // wasm.free(resPtr);
      // return JSON.parse(json);

      // For demo, return a fake note array like [{time, midi, velocity, duration}]
      // Replace this with the actual WASM call above!
      // The tile logic below will map midi to lane etc.
      return [
        {time: 0.0, midi: 60, velocity: 1.0, duration: 0.4},
        {time: 0.35, midi: 62, velocity: 1.0, duration: 0.4},
        {time: 0.7, midi: 64, velocity: 1.0, duration: 0.4},
        {time: 1.05, midi: 65, velocity: 1.0, duration: 0.4},
        {time: 1.4, midi: 67, velocity: 1.0, duration: 0.4}
      ];
    }

    // --------- MIDI FILE UPLOAD HANDLING (WASM version) ----------
    document.getElementById('midi-upload').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      showLoading(true, "Reading file...");
      const reader = new FileReader();
      reader.onload = async function(ev) {
        try {
          setLoadingMsg("Parsing MIDI (WASM)...");
          let notes = await parseMidiWasm(ev.target.result);
          // Map notes to lanes (as before)
          let minPitch = Math.min(...notes.map(n => n.midi));
          let maxPitch = Math.max(...notes.map(n => n.midi));
          let pitchRange = maxPitch - minPitch + 1;
          let laneSize = Math.ceil(pitchRange / LANES);
          midiNotes = notes.map(note => {
            let midiVal = note.midi - minPitch;
            let lane = Math.max(0, Math.min(LANES - 1, Math.floor(midiVal / laneSize)));
            return { ...note, lane };
          });
          midiDuration = midiNotes.length > 0 ? midiNotes[midiNotes.length-1].time + 2.0 : 0;
          resetGame();
          showLoading(false);
          alert("MIDI processed! " + midiNotes.length + " tiles generated. Press Play!");
        } catch (err) {
          showLoading(false);
          alert("Failed to parse MIDI: " + err);
        }
      };
      reader.readAsArrayBuffer(file);
    });

    // --- REST OF GAME LOGIC BELOW (unchanged, except midiNotes are now WASM parsed) ---

    document.getElementById('play-btn').onclick = () => {
      if (midiNotes && midiNotes.length > 0 && !isPlaying) {
        resetGame();
        isPlaying = true;
        startTime = performance.now();
      }
    };
    document.getElementById('stop-btn').onclick = () => {
      isPlaying = false;
      resetGame();
      drawAll();
    };

    function resetGame() {
      tiles = Array.from({length: LANES}, () => []);
      pendingMidi = midiNotes && midiNotes.length > 0 ? midiNotes.slice() : [];
      startTime = null;
      earlyPressAnim = Array(LANES).fill(0);
    }

    // --- TILE SCHEDULING ---
    let pendingMidi = [];
    function scheduleTiles(elapsed) {
      if (!pendingMidi || !isPlaying) return;
      let t = elapsed * playbackRate;
      for (let lane = 0; lane < LANES; ++lane) {
        let idx = pendingMidi.findIndex(n => n.lane === lane && n.time <= t + tileLeadTime());
        if (idx === -1) continue;
        let note = pendingMidi[idx];
        let arr = tiles[lane];
        let lastY = arr.length > 0 ? arr[arr.length-1].y : -TILE_HEIGHT;
        if (lastY < -TILE_HEIGHT - TILE_SPAWN_GAP) {
          let spawnY = -TILE_HEIGHT;
          let tile = {
            lane: lane,
            color: LANE_COLORS[lane],
            y: spawnY,
            width: LANE_WIDTH * TILE_WIDTH_RATIO,
            x: lane * LANE_WIDTH + LANE_WIDTH*(1-TILE_WIDTH_RATIO)/2,
            height: TILE_HEIGHT,
            state: "falling",
            anim: 0,
            hit: false,
            scheduledTime: note.time / playbackRate,
            played: false
          };
          arr.push(tile);
          pendingMidi.splice(idx, 1);
        }
      }
    }

    function tileLeadTime() {
      return (HIT_LINE_Y + TILE_HEIGHT) / (BASE_TILE_SPEED * playbackRate) / FPS;
    }

    function drawBackground() {
      ctx.clearRect(0, 0, W, H);
      let grad = ctx.createLinearGradient(0, 0, 0, H);
      grad.addColorStop(0, "#f6e5bb");
      grad.addColorStop(1, "#c29b5e");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);
      ctx.save();
      ctx.globalAlpha = 0.09;
      for (let i = 0; i < LANES; ++i) {
        ctx.fillStyle = "#a87b3e";
        ctx.fillRect(i * LANE_WIDTH, 0, 10, H);
      }
      ctx.restore();
    }
    function drawLanes() {
      ctx.save();
      for (let i = 1; i < LANES; ++i) {
        ctx.beginPath();
        ctx.strokeStyle = "#bfa76455";
        ctx.lineWidth = 3;
        ctx.moveTo(i * LANE_WIDTH, 0);
        ctx.lineTo(i * LANE_WIDTH, H);
        ctx.stroke();
      }
      ctx.restore();
      let grad = ctx.createLinearGradient(0, HIT_LINE_Y, W, HIT_LINE_Y);
      grad.addColorStop(0, "#ffe065");
      grad.addColorStop(0.5, "#ad8d54");
      grad.addColorStop(1, "#ffe065");
      ctx.save();
      ctx.strokeStyle = grad;
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.moveTo(0, HIT_LINE_Y);
      ctx.lineTo(W, HIT_LINE_Y);
      ctx.stroke();
      ctx.restore();
    }

    function drawTiles() {
      for (let lane = 0; lane < LANES; ++lane) {
        for (let tile of tiles[lane]) {
          ctx.save();
          ctx.globalAlpha = 0.19;
          ctx.fillStyle = "#694116";
          ctx.fillRect(tile.x+4, tile.y+7, tile.width, tile.height);
          ctx.restore();

          ctx.save();
          if (tile.state === "hit") {
            ctx.globalAlpha = Math.max(0, 0.9 - tile.anim/11);
            ctx.fillStyle = "#ffe065";
            ctx.strokeStyle = "#bfa764";
          } else if (tile.state === "missed" || tile.state === "early") {
            ctx.globalAlpha = Math.max(0, 0.92 - tile.anim/9);
            ctx.fillStyle = "#cf6e5e";
            ctx.strokeStyle = "#b24636";
          } else {
            ctx.globalAlpha = 0.94;
            ctx.fillStyle = tile.color;
            ctx.strokeStyle = "#8b6128";
          }
          ctx.lineWidth = 2.2;
          ctx.beginPath();
          ctx.roundRect(tile.x, tile.y, tile.width, tile.height, 10);
          ctx.fill();
          ctx.stroke();
          ctx.restore();

          if (tile.state === "falling") {
            ctx.save();
            ctx.globalAlpha = 0.13;
            ctx.fillStyle = "#fffbe8";
            ctx.beginPath();
            ctx.roundRect(tile.x+4, tile.y+7, tile.width-8, 13, 7);
            ctx.fill();
            ctx.restore();
          }
        }
      }
    }

    function drawCircles() {
      for (let i = 0; i < LANES; ++i) {
        let cx = i * LANE_WIDTH + LANE_WIDTH/2;
        ctx.save();
        ctx.beginPath();
        let grad = ctx.createRadialGradient(cx, CIRCLE_Y, 8, cx, CIRCLE_Y, CIRCLE_RADIUS);
        grad.addColorStop(0, "#fffbe8");
        grad.addColorStop(0.85, "#ffe065");
        grad.addColorStop(1, "#bfa764");
        ctx.fillStyle = grad;
        ctx.arc(cx, CIRCLE_Y, CIRCLE_RADIUS, 0, Math.PI*2);
        ctx.shadowColor = "#bfa764";
        ctx.shadowBlur = 12;
        ctx.fill();
        ctx.restore();
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, CIRCLE_Y, CIRCLE_RADIUS, 0, Math.PI*2);
        ctx.lineWidth = 4;
        ctx.strokeStyle = "#8b6128";
        ctx.stroke();
        ctx.restore();
        ctx.save();
        ctx.font = "bold 2.4rem Georgia";
        ctx.fillStyle = "#8b6128";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "#fffbe8";
        ctx.shadowBlur = 2;
        ctx.fillText(laneLabels[i], cx, CIRCLE_Y);
        ctx.restore();
      }
    }

    function drawAll() {
      drawBackground();
      drawLanes();
      drawTiles();
      drawCircles();
      drawEarlyPress();
    }

    let earlyPressAnim = Array(LANES).fill(0);

    function isTileHittable(tile) {
      return (
        tile.state === "falling" &&
        tile.y + tile.height > HIT_LINE_Y - 18 &&
        tile.y < HIT_LINE_Y + 18
      );
    }
    function isTileEarly(tile) {
      return (
        tile.state === "falling" &&
        tile.y + tile.height < HIT_LINE_Y - 30
      );
    }

    function handleHit(lane) {
      let arr = tiles[lane];
      let idx = arr.findIndex(isTileHittable);
      if (idx !== -1) {
        arr[idx].state = "hit";
        arr[idx].anim = 0;
        arr[idx].hit = true;
      } else {
        let hasEarly = arr.find(isTileEarly);
        if (hasEarly) {
          earlyPressAnim[lane] = 10;
          if (hasEarly.state === "falling") {
            hasEarly.state = "early";
            hasEarly.anim = 0;
            hasEarly.hit = false;
          }
        }
      }
    }

    document.addEventListener('keydown', e => {
      let pressed = e.key.toUpperCase();
      let idx = laneLabels.findIndex(lab => lab === pressed);
      if (idx !== -1) {
        handleHit(idx);
      }
    });

    canvas.addEventListener('mousedown', e => {
      let rect = canvas.getBoundingClientRect();
      let mx = e.clientX - rect.left;
      let my = e.clientY - rect.top;
      for (let i = 0; i < LANES; ++i) {
        let cx = i * LANE_WIDTH + LANE_WIDTH/2;
        let dx = mx - cx, dy = my - CIRCLE_Y;
        if (dx*dx + dy*dy <= CIRCLE_RADIUS*CIRCLE_RADIUS) {
          handleHit(i);
          break;
        }
      }
    });

    function drawEarlyPress() {
      for (let i = 0; i < LANES; ++i) {
        if (earlyPressAnim[i] > 0) {
          let cx = i * LANE_WIDTH + LANE_WIDTH/2;
          ctx.save();
          ctx.beginPath();
          ctx.globalAlpha = 0.23 + 0.25 * (earlyPressAnim[i] / 10);
          ctx.arc(cx, CIRCLE_Y, CIRCLE_RADIUS, 0, Math.PI*2);
          ctx.fillStyle = "#cf6e5e";
          ctx.fill();
          ctx.restore();
          earlyPressAnim[i]--;
        }
      }
    }

    function animate(now) {
      drawAll();
      if (isPlaying && midiNotes && midiNotes.length > 0) {
        if (!startTime) startTime = now;
        let elapsed = (now - startTime) / 1000;
        scheduleTiles(elapsed);
        for (let lane = 0; lane < LANES; ++lane) {
          for (let tile of tiles[lane]) {
            if (tile.state === "falling") {
              tile.y += BASE_TILE_SPEED * playbackRate;
              if (tile.y > HIT_LINE_Y + 32 && tile.state === "falling") {
                tile.state = "missed";
                tile.anim = 0;
              }
            } else if (tile.state === "hit" || tile.state === "missed" || tile.state === "early") {
              tile.anim++;
            }
          }
          tiles[lane] = tiles[lane].filter(tile =>
            (tile.state === "falling") ||
            (tile.state === "hit" && tile.anim < 12) ||
            (tile.state === "missed" && tile.anim < 9) ||
            (tile.state === "early" && tile.anim < 9)
          );
        }
        if ((!pendingMidi || pendingMidi.length === 0) && tiles.every(arr => arr.length === 0)) {
          isPlaying = false;
        }
      }
      requestAnimationFrame(animate);
    }

    // --- INITIAL DEMO (optional, remove if not needed) ---
    function randomDemoNotes() {
      midiNotes = [];
      let t = 0;
      for (let i = 0; i < 40; ++i) {
        let lane = Math.floor(Math.random() * LANES);
        midiNotes.push({
          time: t, midi: 60 + lane, velocity: 0.9, duration: 0.4, lane: lane
        });
        t += 0.35 + Math.random() * 0.25;
      }
      midiDuration = t;
      resetGame();
    }
    randomDemoNotes();
    animate();

  </script>
</body>
</html>